\documentclass[11pt]{amsart}
\usepackage[margin=1in]{geometry}

% Math packages
\usepackage{amsthm, amsmath, amssymb}
\usepackage{thmtools, thm-restate}

% tcolorbox for colored boxes
\usepackage[skins,breakable]{tcolorbox}

% Hyperlinks
\usepackage{hyperref}
\hypersetup{
    colorlinks=true,
    linkcolor=red,
    filecolor=blue,
    citecolor=blue,
    urlcolor=cyan,
}

% tcolorbox styles
\tcbset{
    red/.style={
        enhanced,
        borderline west={1mm}{-2mm}{red},
        colframe=white,
        boxrule=0pt,
        sharp corners,
        breakable,
    }
}

\tcbset{
    blue/.style={
        enhanced,
        borderline west={1mm}{-2mm}{blue},
        colframe=white,
        boxrule=0pt,
        sharp corners,
        breakable,
    }
}

\tcbset{
    green/.style={
        enhanced,
        borderline west={1mm}{-2mm}{green!50},
        colframe=white,
        boxrule=0pt,
        sharp corners,
        breakable,
    }
}

% Complexity classes
\newcommand{\sfP}{\mathsf{P}}
\newcommand{\sfNP}{\mathsf{NP}}
\newcommand{\sfcoNP}{\mathsf{coNP}}

% Vector notation
\renewcommand{\vec}[1]{\boldsymbol{#1}}

% Theorem environments
\theoremstyle{definition}
\declaretheorem{definition}

\theoremstyle{plain}
\declaretheorem[sibling=definition]{theorem}
\declaretheorem[sibling=definition]{corollary}

\title{A Note on the Hardness of Verifying and Generating Reductions}
\author{Mason DiCicco}
\date{}

\begin{document}
\maketitle

\begin{abstract}
This note studies \emph{reductions} between decision problems, commenting on the complexity of two tasks: Verification (is a candidate reduction correct?) and generation (does a correct reduction exist?). We show that (our formulations of) both tasks lie at higher levels of the polynomial hierarchy than the problems themselves.
\end{abstract}

\section{Preliminaries}\label{sec:prelim}

We work with binary strings over the alphabet $\{0,1\}$.  Let $\{0,1\}^n$ denote the set of all $n$-bit strings, and $\{0,1\}^* = \bigcup_{n \ge 0} \{0,1\}^n$ denote the set of all finite binary strings.  For a string $x$, we write $|x|$ for its length.

\begin{tcolorbox}[blue, title={}]
\begin{definition}
A \emph{language} (or \emph{decision problem}) is a subset $L \subseteq \{0,1\}^*$.  The \emph{membership problem} for $L$ is: given $x \in \{0,1\}^*$, decide whether $x \in L$.
\end{definition}
\end{tcolorbox}

\begin{tcolorbox}[blue, title={}]
\begin{definition}
A language $L$ is in $\sfP$ (polynomial time) if there exists a deterministic Turing machine $M$ (a ``decider'') and a polynomial $p$ such that for all $x \in \{0,1\}^*$:
\begin{itemize}
  \item $M(x)$ halts in at most $p(|x|)$ steps, and
  \item $M(x) = 1$ if and only if $x \in L$.
\end{itemize}
\end{definition}
\end{tcolorbox}

\begin{tcolorbox}[blue, title={}]
\begin{definition}
A language $L$ is in $\sfNP$ (nondeterministic polynomial time) if there exists a polynomial-time computable predicate $R$ (a ``verifier'') and a polynomial $s$ such that
\[
  x \in L \;\Longleftrightarrow\; \exists w \in \{0,1\}^{\le s(|x|)} : R(x, w) = 1.
\]
Here, we call $w$ a \emph{witness} for $x$. A language is in $\sfcoNP$ if its complement is in $\sfNP$.
\end{definition}
\end{tcolorbox}

\begin{tcolorbox}[blue, title={}]
\begin{definition}
The \emph{polynomial hierarchy} is defined inductively:
\begin{itemize}
  \item $\Sigma_0^p = \Pi_0^p = \sfP$.
  \item $\Sigma_{k+1}^p = \sfNP^{\Sigma_k^p} = \sfNP^{\Pi_k^p}$ (NP with oracle access to $\Sigma_k^p$ or, equivalently, $\Pi_k^p$).
  \item $\Pi_{k+1}^p = \sfcoNP^{\Sigma_k^p} = \sfcoNP^{\Pi_k^p}$ (coNP with oracle access to $\Sigma_k^p$ or $\Pi_k^p$).
\end{itemize}
Equivalently, $L \in \Sigma_k^p$ iff there exist a poly-time predicate $R$ and polynomials $s_1, \ldots, s_k$ such that
\[
  x \in L \;\Longleftrightarrow\; \exists w_1 \forall w_2 \exists w_3 \cdots Q_k w_k : R(x, w_1, \ldots, w_k),
\]
where $|w_i| \le s_i(|x|)$ and the quantifiers strictly alternate starting with $\exists$.  For $\Pi_k^p$, the quantifiers start with $\forall$. 
\end{definition}
Note that $\Sigma_1^p = \sfNP$ and $\Pi_1^p = \sfcoNP$.
\end{tcolorbox}



\begin{tcolorbox}[blue, title={}]
\begin{definition}
A \emph{polynomial-time reduction} from $F$ to $G$ is a poly-time computable function $M$ satisfying:
\[
  x \in F \;\Longleftrightarrow\; M(x) \in G \quad \text{for all } x.
\]
\end{definition}
\end{tcolorbox}

\begin{tcolorbox}[blue, title={}]
\begin{definition}
A \emph{predicate schema} of depth $k$ is a tuple
\[
  S = (Q_1 w_1, \ldots, Q_k w_k : R(x, \vec{w});\; p, s_1, \ldots, s_k)
\]
where:
\begin{itemize}
  \item Each $Q_i \in \{\exists, \forall\}$ with \textbf{strict alternation}: $Q_{i+1} \neq Q_i$ for all $i < k$.
  \item $R : \{0,1\}^* \times \{0,1\}^* \times \cdots \times \{0,1\}^* \to \{0,1\}$ is a predicate computed by a deterministic Turing machine in time $p(|x|)$ on inputs $(x, w_1, \ldots, w_k)$ where $|w_i| \le s_i(|x|)$.
  \item $p, s_1, \ldots, s_k : \mathbb{N} \to \mathbb{N}$ are polynomials.
\end{itemize}
The schema defines the language
\[
  L_S = \{x \in \{0,1\}^* : Q_1 w_1 \in \{0,1\}^{\le s_1(|x|)} \cdots Q_k w_k \in \{0,1\}^{\le s_k(|x|)}\, R(x, w_1, \ldots, w_k)\}.
\]
\end{definition}
\end{tcolorbox}

\textbf{Examples:} 
\begin{itemize} 
  \item Depth $0$ reduces to $(R(x); p)$ with no quantifiers, so $L_S = \{x : R(x)\}$ where $R$ is computable in time $p(|x|)$. This captures $\sfP$.
  \item Depth $1$ with leading $\exists$ captures $\sfNP$: ``is there a witness $w$ such that $R(x,w)$ holds?''
  \item Depth $1$ with leading $\forall$ captures $\sfcoNP$: ``for all $w$, does $R(x,w)$ hold?''
  \item A depth-$k$ schema with leading $\exists$ defines a $\Sigma_k^p$ language; with leading $\forall$, a $\Pi_k^p$ language.
\end{itemize}

\medskip
\noindent\textbf{Conventions.}\quad
Bounds $n, t, \ell, s$ are given in unary.  Machines and circuits have polynomial-size encodings.  All completeness results are under polynomial-time many-one reductions.

\section{Verification}\label{sec:verify}

Given a candidate reduction $M$, bounds $1^n, 1^t$, and specifications of languages $F$ and $G$, does $M$ correctly reduce $F$ to $G$ on all $n$-bit inputs in time $t$? Verifying correctness requires checking a universal property---$M$ must preserve membership for \emph{every} input---which introduces one quantifier alternation beyond the complexity of the language specifications themselves.

\subsection{General Verification Theorem}

We first establish the general result for languages specified by predicate schemas.  The important special cases of circuits and $\sfNP$ verifiers then follow as immediate corollaries.

\begin{tcolorbox}[blue, title={}]
\begin{definition}[\textsc{Correct}]
\textbf{Input:} Tuple $\langle M, S_F, S_G, 1^n, 1^t, 1^\ell \rangle$.

\medskip
\textbf{Question:} For all $y \in \{0,1\}^n$, does $M(y)$ halt in $\le t$ steps with $|M(y)| = \ell$, and satisfy
\[
  y \in L_{S_F} \;\Longleftrightarrow\; M(y) \in L_{S_G}\,?
\]
\end{definition}
\end{tcolorbox}

\begin{tcolorbox}[red, title={}]
\begin{theorem}\label{thm:ph-verify}
Let $k = \max(\mathrm{depth}(S_F), \mathrm{depth}(S_G))$.  Then:
\[
  \boxed{\textsc{Correct} \text{ is } \Pi_{k+1}^p\text{-complete.}}
\]
\end{theorem}
\end{tcolorbox}

\begin{proof}
Write $A(y)\equiv y\in L_{S_F}$ and $B(z)\equiv z\in L_{S_G}$. Each is a depth-$k$ predicate, lying in $\Sigma_k^p$ or $\Pi_k^p$ depending on its leading quantifier.

\emph{Membership.} The correctness condition is $\forall y\,(A(y)\Leftrightarrow B(M(y)))$.
Negating gives
\[
  \exists y\;\bigl[(A(y)\land\neg B(M(y)))\lor(\neg A(y)\land B(M(y)))\bigr].
\]
Each disjunct is a conjunction of a $\Sigma_k^p$ predicate and a $\Pi_k^p$ predicate; by merging quantifier prefixes, each conjunction remains in $\Sigma_k^p$. A disjunction of $\Sigma_k^p$ predicates stays in $\Sigma_k^p$. The outer $\exists y$ adds one alternation, so the negation lies in $\Sigma_{k+1}^p$, and the original problem is in $\Pi_{k+1}^p$.

\emph{Hardness.} Reduce from $\Pi_{k+1}$-\textsc{QSAT}. Given $\Phi=\forall u\,Q_1w_1\cdots Q_kw_k:\psi(u,\vec w)$, set $S_F$ to encode $Q_1w_1\cdots Q_kw_k:\psi(u,\vec w)$ (with $u$ as input), $S_G$ the trivial true language, and $M=\mathrm{id}$. Correctness becomes $\forall u\,(u\in L_{S_F}\Leftrightarrow\mathsf{true})=\Phi$. Since $S_F$ has leading quantifier opposite to $\forall$, its complement is $\Pi_k^p$, so $\exists u\,(u\notin L_{S_F})\in\Sigma_{k+1}^p$, confirming $\Pi_{k+1}^p$-hardness.
\end{proof}

\subsection{Corollaries for Circuits and NP Verifiers}

The most natural ways to specify decision problems---Boolean circuits and $\sfNP$ verifiers---correspond to depth $0$ and depth $1$ schemas, respectively.  Applying the general theorem immediately yields:

\begin{tcolorbox}[green, title={}]
\begin{definition}[\textsc{Correct-Circ}]
\textbf{Input:} Tuple $\langle M, C_F, C_G, 1^n, 1^t, 1^\ell \rangle$ where $C_F$ is an $n$-input Boolean circuit and $C_G$ is an $\ell$-input Boolean circuit.

\medskip
\textbf{Question:} For all $y \in \{0,1\}^n$: $M(y)$ halts in $\le t$ steps, $|M(y)| = \ell$, and $C_F(y) = C_G(M(y))$?
\end{definition}
\end{tcolorbox}

\begin{corollary}\label{cor:circ}
$\textsc{Correct-Circ}$ is $\sfcoNP$-complete.
\end{corollary}

\begin{proof}
A Boolean circuit defines a depth-$0$ predicate (no quantifiers, just a polynomial-time computation).  By Theorem~\ref{thm:ph-verify} with $k = 0$, verification is $\Pi_1^p = \sfcoNP$-complete.  Concretely, the correctness condition $\forall y : C_F(y) = C_G(M(y))$ is a single universal quantifier over a polynomial-time predicate.  For hardness, reduce from \textsc{Circuit-Tautology} by setting $M = M_{\mathrm{id}}$, $C_G \equiv 1$, so correctness becomes ``$C_F$ is a tautology.''
\end{proof}

\begin{tcolorbox}[green, title={}]
\begin{definition}[\textsc{Correct-NP}]\label{def:correct-np}
\textbf{Input:} Tuple $\langle M, V_F, V_G, 1^n, 1^t, 1^\ell, 1^{s_F}, 1^{s_G} \rangle$ where $V_F, V_G$ are $\sfNP$ verifiers.

\medskip
\textbf{Question:} For all $y \in \{0,1\}^n$: $M(y)$ halts in $\le t$ steps, $|M(y)| = \ell$, and
\[
  (\exists w\, V_F(y, w) = 1) \;\Longleftrightarrow\; (\exists w\, V_G(M(y), w) = 1)\,?
\]
\end{definition}
\end{tcolorbox}

\begin{corollary}\label{cor:np}
$\textsc{Correct-NP}$ is $\Pi_2^p$-complete.
\end{corollary}

\begin{proof}
An $\sfNP$ verifier defines a depth-$1$ predicate with leading $\exists$: $x \in L$ iff $\exists w\, V(x, w)$.  By Theorem~\ref{thm:ph-verify} with $k = 1$, verification is $\Pi_2^p$-complete.  The correctness condition expands to
\[
  \forall y : (\exists w_F\, V_F(y, w_F)) \Leftrightarrow (\exists w_G\, V_G(M(y), w_G)).
\]
To see this is $\Pi_2^p$: the biconditional $P \Leftrightarrow Q$ is equivalent to $(P \land Q) \lor (\neg P \land \neg Q)$.  When $P = \exists w_F\, V_F(\cdot)$ and $Q = \exists w_G\, V_G(\cdot)$, each disjunct involves a conjunction of $\Sigma_1^p$ and $\Pi_1^p$ predicates, which remains in $\Sigma_1^p \cup \Pi_1^p \subseteq \Sigma_2^p$.  The outer $\forall y$ then gives $\Pi_2^p$.  Hardness follows from Theorem~\ref{thm:ph-verify}, or directly: reduce from $\Pi_2$-\textsc{QSAT} $\forall u\, \exists v : \varphi(u, v)$ by setting $V_F(u, v) = \varphi(u, v)$, $V_G \equiv 1$, and $M = M_{\mathrm{id}}$.
\end{proof}

\section{Generation}\label{sec:generate}

Given specifications $S_F, S_G$, does there \emph{exist} a correct reduction?

\begin{tcolorbox}[blue, title={}]
\begin{definition}[\textsc{Reducible}]
\textbf{Input:} Tuple $\langle S_F, S_G, 1^n, 1^t, 1^\ell, 1^s \rangle$.

\medskip
\textbf{Question:} Does there exist a machine $M$ with $|M| \le s$ such that
\[
  \langle M, S_F, S_G, 1^n, 1^t, 1^\ell \rangle \in \textsc{Correct}\,?
\]
\end{definition}
\end{tcolorbox}

\begin{tcolorbox}[red, title={}]
\begin{theorem}\label{thm:gen}
Let $k = \max(\mathrm{depth}(S_F), \mathrm{depth}(S_G))$.  Then:
\[
  \boxed{\textsc{Reducible} \text{ is } \Sigma_{k+2}^p\text{-complete.}}
\]
\end{theorem}
\end{tcolorbox}

\begin{proof}
\emph{Membership.} The question is
\[
  \exists M\ (|M|\le s)\; \bigl(\forall y\; A(y)\Leftrightarrow B(M(y))\bigr).
\]
By Theorem~\ref{thm:ph-verify} the inner predicate ``$\forall y\;A(y)\Leftrightarrow B(M(y))$'' is in $\Pi_{k+1}^p$, and the outer $\exists M$ (over descriptions of polynomial length since $s$ is unary) yields membership in $\Sigma_{k+2}^p$.

\emph{Hardness.} Reduce from $\Sigma_{k+2}$-\textsc{QSAT}. Given
\[
  \Phi=\exists x\;\forall y\; Q_1w_1\cdots Q_k w_k:\psi(x,y,\vec w),
\]
encode each candidate $x\in\{0,1\}^r$ by a machine $M_x$ that outputs $x\|y$ on input $y$ (so $|M_x|=r+O(1)$). Put $S_F=\{0,1\}^n$ (always true) and let $S_G$ interpret its input $z$ as $(x,y)$ and test $Q_1\cdots Q_k\;\psi(x,y,\vec w)$. Then $M_x$ is a valid reduction iff $\forall y\;Q_1\cdots Q_k\;\psi(x,y,\vec w)$, so $\exists M$ passing \textsc{Correct} iff $\exists x\,\forall y\,Q_1\cdots Q_k\;\psi$, i.e.\ iff $\Phi$ holds. This is a polynomial-time reduction, giving $\Sigma_{k+2}^p$-hardness.
\end{proof}

\paragraph{Remark.}
The unbounded problem (``does a poly-time reduction exist for all input lengths?'') is undecidable.  Our bounded version captures the complexity of finding reductions for a specific input length.

\begin{tcolorbox}[blue, title={}]
\begin{definition}[\textsc{Reducible-Unbounded}]
\textbf{Input:} Turing machines $M_F, M_G$ specifying languages $L_F = L(M_F)$ and $L_G = L(M_G)$.

\medskip
\textbf{Question:} Does there exist a polynomial-time computable function $f$ such that for all $x \in \{0,1\}^*$:
\[
  x \in L_F \;\Longleftrightarrow\; f(x) \in L_G\,?
\]
\end{definition}
\end{tcolorbox}

\begin{tcolorbox}[red, title={}]
\begin{theorem}\label{thm:undecidable}
\textsc{Reducible-Unbounded} is undecidable.
\end{theorem}
\end{tcolorbox}

\begin{proof}
We reduce from the language emptiness problem: given a Turing machine $T$, is $L(T) = \emptyset$?  This is undecidable by Rice's theorem.

Given $T$, construct an instance of \textsc{Reducible-Unbounded} with $L_F = L(T)$ and $L_G = \emptyset$ (the empty language, specified by a machine that immediately rejects).

We claim: a polynomial-time reduction from $L_F$ to $L_G$ exists if and only if $L_F = \emptyset$.

\begin{itemize}
  \item ($\Rightarrow$) Suppose $f$ is a reduction and $L_F \neq \emptyset$.  Let $x \in L_F$.  Then by correctness of $f$, we need $f(x) \in L_G = \emptyset$, a contradiction.
  
  \item ($\Leftarrow$) If $L_F = \emptyset$, then any function $f$ is a valid reduction: the condition $x \in L_F \Leftrightarrow f(x) \in L_G$ becomes $\mathsf{false} \Leftrightarrow \mathsf{false}$, which holds for all $x$.
\end{itemize}

Thus \textsc{Reducible-Unbounded} decides language emptiness, so it is undecidable.
\end{proof}

\end{document}
